<head>
  <meta charset="utf-8">
  <style type="text/css">
    
* {
    -webkit-box-sizing: border-box;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
}
body {
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size: 14px;
    line-height: 1.5;
    color: #333;
    background-color: #fafbfc;
}
.content-wrapper {
    position: absolute;
    top: 0px;
    left: 0px;
    margin-left: 360px;
    margin-bottom: 60px;
    width: 1000px;
    background-color: #fff;
    padding: 5px 40px;
}
.content {
    margin-left: auto;
    margin-right: auto;
    max-width: 750px;
    padding-bottom: 50px
}
.footer {
    position: fixed;
    right: 0;
    bottom: 0;
    left: 0;
    padding: 1rem;
    background-color: #efefef;
    text-align: center;
}
h1, h2, h3, h4, h5, h6 {
    font-family: inherit;
    font-weight: 500;
    line-height: 1.1;
    color: inherit;
}
h1, h2, h3 {
    margin-top: 25px;
    margin-bottom: 10px;
}
h1 {
    font-size: 32px;
}
h2 {
    display: block;
    font-size: 25px;
    font-weight: bold;
}
h3 {
    font-size: 23px;
}
h4 {
    margin-top: 10px;
    margin-bottom: 10px;
    font-size: 18px;
}
pre {
    display: block;
    padding: 9.5px;
    margin: 0 0 10px;
    font-size: 13px;
    line-height: 1.42857143;
    color: #333;
    word-break: break-all;
    word-wrap: break-word;
    background-color: #f5f5f5;
    border: 1px solid #ccc;
    border-radius: 4px;
}
a:hover {
    color: #071269;
    text-decoration: underline;
}
a {
    color: #071269;
    text-decoration: none;
}
code {
    font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
    padding: 2px 4px;
    font-size: 90%;
    color: #484848;
    background-color: #f9f2f4;
    border-radius: 4px;
}
pre code {
    padding: 0;
    font-size: inherit;
    color: inherit;
    white-space: pre-wrap;
    background-color: transparent;
    border-radius: 0;
}
.language-js {
    padding: 9.5px;
    display: block;
    overflow-x: auto;
    padding: 0.5em;
    color: #333;
    background: #f8f8f8;
}
.emoji_warning {
    color: #B71C1C;
    padding-left: 4px;
    padding-right: 3px;
    font-size: 1.3em;
}
.sidebar {
    height: 100%;
    width: 360px;
    position: fixed;
    z-index: 1;
    top: 0;
    left: 0;
    background-color: #fafafa;
    overflow-x: hidden;
    padding: 5px 20px;
    font-size: 1.2em;
    line-height: 2em;
}
.sidebar a {
    color: #364149;
}
.sidebar a:hover {
    text-decoration: none;
    color: #008cff;
}
.sidebar ul {
  list-style-type: none;
}
.header {
  top: 0;
  left: 0;
  width: 100%;
  background-color: #fff;
}

  </style>
<style type="text/css">
    
/*

github.com style (c) Vasily Polovnyov <vast@whiteants.net>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #333;
  background: #f8f8f8;
}

.hljs-comment,
.hljs-quote {
  color: #998;
  font-style: italic;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-subst {
  color: #333;
  font-weight: bold;
}

.hljs-number,
.hljs-literal,
.hljs-variable,
.hljs-template-variable,
.hljs-tag .hljs-attr {
  color: #008080;
}

.hljs-string,
.hljs-doctag {
  color: #d14;
}

.hljs-title,
.hljs-section,
.hljs-selector-id {
  color: #900;
  font-weight: bold;
}

.hljs-subst {
  font-weight: normal;
}

.hljs-type,
.hljs-class .hljs-title {
  color: #458;
  font-weight: bold;
}

.hljs-tag,
.hljs-name,
.hljs-attribute {
  color: #000080;
  font-weight: normal;
}

.hljs-regexp,
.hljs-link {
  color: #009926;
}

.hljs-symbol,
.hljs-bullet {
  color: #990073;
}

.hljs-built_in,
.hljs-builtin-name {
  color: #0086b3;
}

.hljs-meta {
  color: #999;
  font-weight: bold;
}

.hljs-deletion {
  background: #fdd;
}

.hljs-addition {
  background: #dfd;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}

  </style>
  <title>Manifest Object - RxPlayer Documentation</title>
  </head>
<body>
  <div class="page-wrapper">
    <div class="sidebar"><html><head></head><body><p><a href="#title-Manifest%20Object">Manifest Object</a></p>
<ul>
<li><a href="#chapter-Overview">Overview</a></li>
<li><a href="#chapter-Structure%20of%20a%20Manifest%20Object">Structure of a Manifest Object</a>
<ul>
<li><a href="#subchapter-properties">properties</a></li>
</ul>
</li>
<li><a href="#chapter-Structure%20of%20a%20Period%20Object">Structure of a Period Object</a>
<ul>
<li><a href="#subchapter-properties">properties</a></li>
</ul>
</li>
<li><a href="#chapter-Structure%20of%20an%20Adaptation%20Object">Structure of an Adaptation Object</a>
<ul>
<li><a href="#subchapter-properties">properties</a></li>
<li><a href="#subchapter-methods">methods</a></li>
</ul>
</li>
<li><a href="#chapter-Structure%20of%20a%20Representation%20Object">Structure of a Representation Object</a>
<ul>
<li><a href="#subchapter-properties">properties</a></li>
</ul>
</li>
<li><a href="#chapter-Structure%20of%20a%20RepresentationIndex%20Object">Structure of a RepresentationIndex Object</a>
<ul>
<li><a href="#subchapter-methods">methods</a></li>
</ul>
</li>
<li><a href="#chapter-Structure%20of%20a%20Segment%20Object">Structure of a Segment Object</a>
<ul>
<li><a href="#subchapter-properties">properties</a></li>
</ul>
</li>
</ul>
</body></html></div>
    <div class="content-wrapper">
      
<div class="header">
  <div class="header-content">
    <a href="./index.html">API Documentation</a>
    <a href="todo">Demo Page</a>
  </div>
</div>
      <div class="content">
        <html><head></head><body><p><a name="title-Manifest%20Object"></a></p>
<h1>Manifest Object</h1>
<p><a name="overview"></a>
<a name="chapter-Overview"></a></p>
<h2>Overview</h2>
<p>A manifest Object and its sub-parts are data structures returned by multiple
APIs of the player.</p>
<p>Basically, the structure of a Manifest file has the following hierarchy:</p>
<pre><code>Manifest Object
  ...Manifest data and methods
  Adaptation Object
    ...Adaptation data and methods
    Representation Object
      ...Representation data and methods
      RepresentationIndex Object
        ...RepresentationIndex data and methods
          SegmentObject
          ...SegmentObject data
</code></pre>
<p>Due to this highly hierachical structure, each level will be described in its
own chapter here.</p>
<p><span class="emoji emoji_warning">⚠️</span> Like in the rest of this documentation, any variable or method not
defined here can change without notice.</p>
<p>Only use the documented variables and open an issue if you think it’s not
enough.</p>
<p><a name="manifest"></a>
<a name="chapter-Structure%20of%20a%20Manifest%20Object"></a></p>
<h2>Structure of a Manifest Object</h2>
<p>The Manifest Object represents the manifest file of the content loaded.</p>
<p><a name="manifest-props"></a>
<a name="subchapter-properties"></a></p>
<h3>properties</h3>
<p>The manifest Object has the following properties.</p>
<h4>periods</h4>
<p><em>type</em>: <code>Array.&lt;Period&gt;</code></p>
<p>A single Manifest instance can contain multiple Periods, which are periods of
time for which the list of available type of contents (audio tracks, subtitles,
video tracks…) can be different.</p>
<p>Such example of Periods could be multiple Programs of a live contents, which can
be each in different languages, for example.</p>
<p>The player will switch smoothly across subsequent Periods within playback.</p>
<p>Most Streaming technologies (e.g. HLS and Smooth) do not have a “Period”
concept. For those, the Manifest will only have one Period for the whole
content.</p>
<h4>adaptations</h4>
<p><em>type</em>: <code>Object</code></p>
<p>:warn: This property is deprecated and is only here for legacy reasons.</p>
<p>Adaptation objects for the first Period.</p>
<p>Both of those lines have the same effect:</p>
<pre><code class="language-js"><span class="hljs-built_in">console</span>.log(manifest.adaptations);
<span class="hljs-built_in">console</span>.log(manifest.periods[<span class="hljs-number">0</span>].adaptations);
</code></pre>
<p>See <a href="#period-props">the Period chapter</a> for more informations on Adaptations.</p>
<h4>isLive</h4>
<p><em>type</em>: <code>Boolean</code></p>
<p><code>true</code> if the content is a live content, <code>false</code> for non-live contents.</p>
<h4>uris</h4>
<p><em>type</em>: <code>Array.&lt;string&gt;</code></p>
<p>The list of uris that can be used to refer to the manifest file.</p>
<h4>transport</h4>
<p><em>type</em>: <code>string</code></p>
<p>The type of transport used. For now, this can only be equal to either <code>dash</code>
or <code>smooth</code>.</p>
<p><a name="period"></a>
<a name="chapter-Structure%20of%20a%20Period%20Object"></a></p>
<h2>Structure of a Period Object</h2>
<p>A period is an object describing what to play during a certain time periods.</p>
<p>A manifest can have a single period, which means that the played content do not
change its characteristics (same languages, same bitrates etc.) or multiple
ones.</p>
<p>A good example of a content with multiple periods would be a live channel
broadcasting multiple foreign films. Each film, being in a different language,
will need to be part of a new Period.</p>
<p><a name="period-props"></a>
<a name="subchapter-properties"></a></p>
<h3>properties</h3>
<h4>id</h4>
<p><em>type</em>: <code>string</code></p>
<p>The id of an adaptation should be a string unique to that Period. It serves
identifications purpose, when updating the manifest for example.</p>
<h4>start</h4>
<p><em>type</em>: <code>Number</code></p>
<p>Start time at which the Period begins in the whole content, in seconds.</p>
<h4>end</h4>
<p><em>type</em>: <code>Number|undefined</code></p>
<p>End time at which the Period ends in the whole content, in seconds.</p>
<p>If not set or set to undefined, it means that the end is unknown, in which case
it is the current last content of the current manifest.</p>
<h4>adaptations</h4>
<p><em>type</em>: <code>Object</code></p>
<p>The adaptations (tracks if you want) for the current content, per-type
(audio/video/text/image).</p>
<p>See <a href="#adaptation">the Adaptation chapter</a> for more info about an Adaptation’s
structure.</p>
<p>The adaptation object <em>can</em> contain any of the following keys:</p>
<ul>
<li>audio (<code>Array.&lt;Adaptation&gt;</code>): The audio adaptation(s) available.</li>
<li>video (<code>Array.&lt;Adaptation&gt;</code>): The video adaptation(s) available.</li>
<li>text (<code>Array.&lt;Adaptation&gt;</code>): The text adaptation(s) available.</li>
<li>image (<code>Array.&lt;Adaptation&gt;</code>): The image adaptation(s) available.</li>
</ul>
<p><a name="adaptation"></a>
<a name="chapter-Structure%20of%20an%20Adaptation%20Object"></a></p>
<h2>Structure of an Adaptation Object</h2>
<p>An adaptation is a set of streams representing the exact same contents in
multiple forms (different sizes, different bitrates…). Concretely, a frequent
usecase is to have a single video adaptation and multiple audio ones, one for
each language available.</p>
<p>As such, it is also often called in the API a <code>track</code>.</p>
<p><a name="adaptation-props"></a>
<a name="subchapter-properties"></a></p>
<h3>properties</h3>
<h4>id</h4>
<p><em>type</em>: <code>string</code></p>
<p>The id of an adaptation should be a string unique to that adaptation. It serves
identifications purpose, when updating the manifest for example.</p>
<h4>type</h4>
<p><em>type</em>: <code>string</code></p>
<p>The type of the Adaptation. The possible types are:</p>
<ul>
<li><code>"video"</code></li>
<li><code>"audio"</code></li>
<li><code>"text"</code></li>
<li><code>"image"</code></li>
</ul>
<h4>language</h4>
<p><em>type</em>: <code>string|undefined</code></p>
<p>The language of the adaptation. This is particularly useful for audio and text
adaptations.</p>
<p>Note that this property is not always present in an Adaptation.</p>
<h4>normalizedLanguage</h4>
<p><em>type</em>: <code>string|undefined</code></p>
<p>An attempt to translate the language of the adaptation into an ISO 639-3 code.
If the translation attempt fails (no corresponding ISO 639-3 language code is
found), it will equal the value of <code>language</code></p>
<p>Note that this property is not always present in an Adaptation.</p>
<h4>isAudioDescription</h4>
<p><em>type</em>: <code>Boolean|undefined</code></p>
<p>This property only makes sense for audio adaptations. In this case, if <code>true</code>
it means that the audio track has added commentaries for the visually impaired.</p>
<h4>isClosedCaption</h4>
<p><em>type</em>: <code>Boolean|undefined</code></p>
<p>This property only makes sense for text adaptations. In this case, if <code>true</code>
it means that the text track has added hints for the hard of hearing.</p>
<h4>representations</h4>
<p><em>type</em>: <code>Array.&lt;Representation&gt;</code></p>
<p>The represesentations for this adaptation.</p>
<p>See <a href="#representation">the Representation chapter</a> for more info about a
Representation’s structure.</p>
<p><a name="adaptation-meth"></a>
<a name="subchapter-methods"></a></p>
<h3>methods</h3>
<h4>getAvailableBitrates</h4>
<p><em>return value</em>: <code>Array.&lt;Number&gt;</code></p>
<p>Returns every bitrates available for this adaptation.</p>
<p><a name="representation"></a>
<a name="chapter-Structure%20of%20a%20Representation%20Object"></a></p>
<h2>Structure of a Representation Object</h2>
<p>A representation is an adaptation encoded in a certain way. It is defined by
multiple values (a codec, a bitrate). Only some of them are documented here (as
stated before, open an issue if you would like to access other properties).</p>
<p><a name="representation-props"></a>
<a name="subchapter-properties"></a></p>
<h3>properties</h3>
<h4>id</h4>
<p><em>type</em>: <code>string</code></p>
<p>The id of a representation should be a string unique to that representation.</p>
<h4>bitrate</h4>
<p><em>type</em>: <code>Number</code></p>
<p>The bitrate of the representation.</p>
<h4>codec</h4>
<p><em>type</em>: <code>string|undefined</code></p>
<p>The codec of the representation</p>
<h4>height</h4>
<p><em>type</em>: <code>Number|undefined</code></p>
<p>This property makes the most sense for video representations.
It defines the height of the video, in pixels.</p>
<h4>width</h4>
<p><em>type</em>: <code>Number|undefined</code></p>
<p>This property makes the most sense for video representations.
It defines the width of the video, in pixels.</p>
<h4>index</h4>
<p><em>type</em>: <code>RepresentationIndex</code></p>
<p>The represesentation index for this adaptation.</p>
<p>See <a href="#representation-index">the RepresentationIndex chapter</a> for more info about
a Representation’s structure.</p>
<p><a name="representation-index"></a>
<a name="chapter-Structure%20of%20a%20RepresentationIndex%20Object"></a></p>
<h2>Structure of a RepresentationIndex Object</h2>
<p>A RepresentationIndex is a uniform representation of the segment index in the
manifest.</p>
<p>That’s the part that calculates which segments will be needed. Because the index
can be different depending on the type of contents/transport most interactions
here are done through few methods which hide the complexity underneath.</p>
<p><a name="representation-index-meth"></a>
<a name="subchapter-methods"></a></p>
<h3>methods</h3>
<h4>getSegments</h4>
<p><em>arguments</em>:</p>
<ul>
<li>
<p><em>up</em> (<code>Number</code>): The position, in seconds from which you want to get the
segment.</p>
</li>
<li>
<p><em>duration</em> (<code>Number</code>): The duration in seconds from the asked position</p>
</li>
</ul>
<p><em>return value</em>: <code>Array.&lt;Segment&gt;</code></p>
<p>Returns the needed segments as defined by the current manifest during an asked
timeframe.</p>
<p>See <a href="#segment">the Segment chapter</a> for more info about a Segment’s structure.</p>
<p><a name="segment"></a>
<a name="chapter-Structure%20of%20a%20Segment%20Object"></a></p>
<h2>Structure of a Segment Object</h2>
<p>A Segment object defines a segment, as generated by the RepresentationIndex.</p>
<p>Those segments can have multiple useful properties which for the most part are
described here.</p>
<p><a name="segment-props"></a>
<a name="subchapter-properties"></a></p>
<h3>properties</h3>
<h4>id</h4>
<p><em>type</em>: <code>string</code></p>
<p>The id of an adaptation should be a string unique to that segment.</p>
<h4>timescale</h4>
<p><em>type</em>: <code>Number</code></p>
<p>The timescale in which the duration and time are expressed.</p>
<p>Basically, divide any of those by the timescale to obtain seconds.</p>
<h4>duration</h4>
<p><em>type</em>: <code>Number|undefined</code></p>
<p>The duration, timescaled, of the Segments in s.</p>
<h4>time</h4>
<p><em>type</em>: <code>Number</code></p>
<p>The start time, timescaled, of the Segments in s.</p>
<h4>isInit</h4>
<p><em>type</em>: <code>Boolean|undefined</code></p>
<p>If true, the segment concerned is an init segment.</p>
<h4>range</h4>
<p><em>type</em>: <code>Array.&lt;Number&gt;|null|undefined</code></p>
<p>If defined, it means that the segment is defined in a certain byte range
remotely. In this case, the array contains two elements, the start byte and the
end byte.</p>
<h4>indexRange</h4>
<p><em>type</em>: <code>Array.&lt;Number&gt;|null|undefined</code></p>
<p>If defined, it means that a segment index is defined in a certain byte range
remotely. In this case, the array contains two elements, the start byte and the
end byte.</p>
<h4>number</h4>
<p><em>type</em>: <code>Number|undefined</code></p>
<p>The number of the segment (if numbered), useful with certain types of index.</p>
</body></html>
      </div>
    </div>
    
  </div>
</body>