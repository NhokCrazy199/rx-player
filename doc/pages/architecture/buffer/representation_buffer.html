<head>
  <meta charset="utf-8">
  <style type="text/css">
    
* {
    -webkit-box-sizing: border-box;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
}
body {
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size: 14px;
    line-height: 1.5;
    color: #333;
    background-color: #fafbfc;
}
.content-wrapper {
    position: absolute;
    top: 0px;
    left: 0px;
    margin-left: 360px;
    margin-bottom: 60px;
    width: 1000px;
    background-color: #fff;
    padding: 5px 40px;
}
.content {
    margin-left: auto;
    margin-right: auto;
    max-width: 750px;
    padding-bottom: 50px
}
.footer {
    position: fixed;
    right: 0;
    bottom: 0;
    left: 0;
    padding: 1rem;
    background-color: #efefef;
    text-align: center;
}
h1, h2, h3, h4, h5, h6 {
    font-family: inherit;
    font-weight: 500;
    line-height: 1.1;
    color: inherit;
}
h1, h2, h3 {
    margin-top: 25px;
    margin-bottom: 10px;
}
h1 {
    font-size: 32px;
}
h2 {
    display: block;
    font-size: 25px;
    font-weight: bold;
}
h3 {
    font-size: 23px;
}
h4 {
    margin-top: 10px;
    margin-bottom: 10px;
    font-size: 18px;
}
pre {
    display: block;
    padding: 9.5px;
    margin: 0 0 10px;
    font-size: 13px;
    line-height: 1.42857143;
    color: #333;
    word-break: break-all;
    word-wrap: break-word;
    background-color: #f5f5f5;
    border: 1px solid #ccc;
    border-radius: 4px;
}
a:hover {
    color: #071269;
    text-decoration: underline;
}
a {
    color: #071269;
    text-decoration: none;
}
code {
    font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
    padding: 2px 4px;
    font-size: 90%;
    color: #484848;
    background-color: #f9f2f4;
    border-radius: 4px;
}
pre code {
    padding: 0;
    font-size: inherit;
    color: inherit;
    white-space: pre-wrap;
    background-color: transparent;
    border-radius: 0;
}
.language-js {
    padding: 9.5px;
    display: block;
    overflow-x: auto;
    padding: 0.5em;
    color: #333;
    background: #f8f8f8;
}
.emoji_warning {
    color: #B71C1C;
    padding-left: 4px;
    padding-right: 3px;
    font-size: 1.3em;
}
.sidebar {
    height: 100%;
    width: 360px;
    position: fixed;
    z-index: 1;
    top: 0;
    left: 0;
    background-color: #fafafa;
    overflow-x: hidden;
    padding: 5px 20px;
    font-size: 1.2em;
    line-height: 2em;
}
.sidebar a {
    color: #364149;
}
.sidebar a:hover {
    text-decoration: none;
    color: #008cff;
}
.sidebar ul {
  list-style-type: none;
}
.header {
  top: 0;
  left: 0;
  width: 100%;
  background-color: #fff;
}

  </style>
<style type="text/css">
    
/*

github.com style (c) Vasily Polovnyov <vast@whiteants.net>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #333;
  background: #f8f8f8;
}

.hljs-comment,
.hljs-quote {
  color: #998;
  font-style: italic;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-subst {
  color: #333;
  font-weight: bold;
}

.hljs-number,
.hljs-literal,
.hljs-variable,
.hljs-template-variable,
.hljs-tag .hljs-attr {
  color: #008080;
}

.hljs-string,
.hljs-doctag {
  color: #d14;
}

.hljs-title,
.hljs-section,
.hljs-selector-id {
  color: #900;
  font-weight: bold;
}

.hljs-subst {
  font-weight: normal;
}

.hljs-type,
.hljs-class .hljs-title {
  color: #458;
  font-weight: bold;
}

.hljs-tag,
.hljs-name,
.hljs-attribute {
  color: #000080;
  font-weight: normal;
}

.hljs-regexp,
.hljs-link {
  color: #009926;
}

.hljs-symbol,
.hljs-bullet {
  color: #990073;
}

.hljs-built_in,
.hljs-builtin-name {
  color: #0086b3;
}

.hljs-meta {
  color: #999;
  font-weight: bold;
}

.hljs-deletion {
  background: #fdd;
}

.hljs-addition {
  background: #dfd;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}

  </style>
  <title>RepresentationBuffer - RxPlayer Documentation</title>
  </head>
<body>
  <div class="page-wrapper">
    <div class="sidebar"><html><head></head><body><p><a href="#title-RepresentationBuffer">RepresentationBuffer</a></p>
<ul>
<li><a href="#chapter-Overview">Overview</a></li>
<li><a href="#chapter-Return%20value">Return value</a></li>
<li><a href="#chapter-Queue%20Algorithm">Queue Algorithm</a></li>
</ul>
</body></html></div>
    <div class="content-wrapper">
      
<div class="header">
  <div class="header-content">
    <a href="./index.html">API Documentation</a>
    <a href="todo">Demo Page</a>
  </div>
</div>
      <div class="content">
        <html><head></head><body><p><a name="title-RepresentationBuffer"></a></p>
<h1>RepresentationBuffer</h1>
<p><a name="chapter-Overview"></a></p>
<h2>Overview</h2>
<p>The RepresentationBuffer download and push segments linked to a given
Representation.</p>
<p>It constructs a list of segments to download, which depend on the current timing
values and parameters.
It then download and push them to a linked SourceBuffer.</p>
<p>Multiple RepresentationBuffer observables can be ran on the same
SourceBuffer without problems. This allows for example smooth transitions
between multiple periods.</p>
<p><a name="chapter-Return%20value"></a></p>
<h2>Return value</h2>
<p>The RepresentationBuffer returns an Observable which emits multiple
notifications depending on what is happening at its core.</p>
<p>Such events tells us when:</p>
<ul>
<li>
<p>Segments are being scheduled for download</p>
</li>
<li>
<p>The RepresentationBuffer has no segment left for download</p>
</li>
<li>
<p>The RepresentationBuffer appended a new Segment to the SourceBuffer</p>
</li>
<li>
<p>The Manifest should be refreshed to allow the RepresentationBuffer to
download future-needed segments.</p>
</li>
<li>
<p>A discontinuity is currently encountered in the Stream (TODO this might not
be the job of the RepresentationBuffer)</p>
</li>
</ul>
<p><a name="chapter-Queue%20Algorithm"></a></p>
<h2>Queue Algorithm</h2>
<p>The RepresentationBuffer depends on a central algorithm to make sure that the
right segments are scheduled for download at any time.</p>
<p>This algorithm constructs a queue of segments to download at any time, and
regularly checks that the segment currently downloaded still corresponds to the
currently most needed Segment.</p>
<p>This list of segments is based on a simple calculus between the current position
and the buffer size we want to achieve.
This list goes then through multiple filters to ensure we’re not queueing them
unnecessarly. Such cases would be, for example, if the segment is already
present in the SourceBuffer at a better quality.</p>
<p>For a clock based on various video events, the strategy is the following:</p>
<ol>
<li>
<p>let <code>segmentQueue</code> be an empty array.</p>
</li>
<li>
<p>On each clock tick, calculate <code>segmentsNeeded</code>, an Array of needed
segments (read: not yet downloaded) from the current time to the buffer
size goal.</p>
<p>Note that the steps <em>2</em> to <em>5</em> can run multiple times while waiting for
a request - happening in step <em>5</em> and <em>8</em>. If that happens,
<code>segmentQueue</code> should equal the last value it has been given.</p>
</li>
<li>
<p>check if there’s a segment currently downloaded (launched in step <em>8</em>)</p>
<p>3-1. If there is none, let segmentQueue be equal to <code>segmentsNeeded</code></p>
<p>3-2. If there is one but for a segment different than the first element
in <code>segmentsNeeded</code> or if <code>segmentsNeeded</code> is empty, abort
this request and let <code>segmentQueue</code> be equal to <code>segmentsNeeded</code>.</p>
<p>3-3. If there is one and is for the same segment than the first element
in <code>segmentsNeeded</code>, let <code>segmentQueue</code> be equal to
<code>segmentsNeeded</code> without its first element.</p>
</li>
<li>
<p>if <code>segmentQueue</code> is empty, go back to <em>2</em>.</p>
</li>
<li>
<p>check if there’s a pending segment request (happening in step <em>8</em>):</p>
<p>5-1. if there’s no segment request, continue</p>
<p>5-1. if there’s a pending segment request, go back to <em>2</em></p>
</li>
<li>
<p>Let <code>currentSegment</code> be the first segment of <code>segmentQueue</code></p>
</li>
<li>
<p>Remove the first segment from <code>segmentQueue</code> (a.k.a. <code>currentSegment</code>)</p>
</li>
<li>
<p>perform a request for <code>currentSegment</code> and wait for it to finish.
During this time, step <em>2</em> to <em>5</em> can run in parallel, and as such
<code>SegmentQueue</code> can be mutated during this process.</p>
</li>
<li>
<p>Once the request is finished, run those tasks in parallel:</p>
<p>9-1. Append the segment to the corresponding SourceBuffer</p>
<p>9-1. go back to step <em>4</em>.</p>
</li>
</ol>
</body></html>
      </div>
    </div>
    
  </div>
</body>